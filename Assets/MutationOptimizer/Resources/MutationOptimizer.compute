#pragma use_dxc
#pragma require Int64
#pragma require Int64BufferAtomics

#pragma multi_compile NORMAL_POSITIONS ALTERNATE_POSITIONS
#pragma multi_compile TRIANGLE_SOLID TRIANGLE_GRADIENT TRIANGLE_GAUSSIAN
#pragma multi_compile OPAQUE_RENDER SORTED_ALPHA_RENDER STOCHASTIC_ALPHA_RENDER
#pragma multi_compile SINGLE_COLOR SPHERICAL_HARMONICS_2 SPHERICAL_HARMONICS_3 SPHERICAL_HARMONICS_4
#pragma multi_compile PER_VERTEX_ERROR PER_TRIANGLE_ERROR
#include "OptimizerPrimitives.hlsl"

#pragma kernel ResetMutationLossAccumulation
#pragma kernel AccumulateMutationLoss
#pragma kernel AccumulateMutationGradientsResetLoss
#pragma kernel ApplyRandomMutation
#pragma kernel CreateNewRandomMutation

#pragma kernel MaintainClosestEdgeNeighbours
#pragma kernel UpdateClosestEdgeNeighbours
#pragma kernel AccumulateMutationLossStructural
#pragma kernel WeldVertices

#pragma kernel EnvMapResetMutationLossAccumulation
#pragma kernel EnvMapAccumulateMutationLoss
#pragma kernel EnvMapAccumulateMutationGradientsResetLoss
#pragma kernel EnvMapApplyRandomMutation
#pragma kernel EnvMapCreateNewRandomMutation

#pragma kernel ResetVisibilityCounter
#pragma kernel DecrementVisibilityCounter
#pragma kernel ListValidAndInvalidPrimitiveIDs
#pragma kernel InitArgsResampling
#pragma kernel InitBitonicSortValidPrimitives
#pragma kernel BitonicSortValidPrimitives
#pragma kernel PairResampling
#pragma kernel TripleResampling

RWStructuredBuffer<PrimitiveData> _PrimitiveBuffer;
int _PrimitiveCount;
int _Dispatch1DOffset;

RWTexture2D<float4> _DepthIDBufferRW;
RWTexture2D<float4> _ResolvedFrameRW;
RWTexture2D<float> _L2Image;
Texture2D<float> _L2ImageMipped;

Texture2D<float4> _DepthIDBufferMutatedMinus;
Texture2D<float4> _DepthIDBufferMutatedPlus;
Texture2D<float4> _ResolvedFrameMutatedMinus;
Texture2D<float4> _ResolvedFrameMutatedPlus;
Texture2D<float4> _TargetTexture;
SamplerState _LinearClampSampler;

int _OutputWidth;
int _OutputHeight;
float _IsOptim2D;
int _CurrentFrame;
int _CurrentOptimStep;
float _IsAntitheticMutation;
float _DoAlphaLoss;

float4x4 _CameraMatrixVP;
int _LossMode;
int _OptimizerMode;
float _CurrentOptimizerMipLevel;
float _OptimizerBeta1;
float _OptimizerBeta2;
int _MutationsPerFrame;
int _OptimSuperSampling;
int _CurrentMutation;
RWStructuredBuffer<PrimitiveData> _PrimitiveBufferMutated;
RWStructuredBuffer<int3> _PrimitiveMutationError;
RWStructuredBuffer<PrimitiveData> _PrimitiveGradientsOptimStep;
RWStructuredBuffer<PrimitiveData> _PrimitiveGradientsMoments1;
RWStructuredBuffer<PrimitiveData> _PrimitiveGradientsMoments2;
RWStructuredBuffer<int> _PrimitiveOptimStepCounter;
RWStructuredBuffer<uint64_t> _StructuralEdgeClosestNeighbourBuffer;
RWStructuredBuffer<int> _StructuralVertexWeldingBuffer;

int _CurrentPairingOffset;
int _FramesUnseenBeforeKill;
int _ViewsPerOptimStep;
float _MinPrimitiveWorldArea;
RWStructuredBuffer<int> _PrimitiveKillCounters;
AppendStructuredBuffer<uint> _AppendValidPrimitiveIDs;
AppendStructuredBuffer<uint> _AppendInvalidPrimitiveIDs;
RWStructuredBuffer<uint2> _SortedValidPrimitiveIDs;
int _PrimitiveCountPow2;
int _SortLoopValueX;
int _SortLoopValueY;
StructuredBuffer<uint> _ReadValidPrimitiveIDs;
StructuredBuffer<uint> _ReadInvalidPrimitiveIDs;
RWStructuredBuffer<uint> _ArgsValidPrimitiveIDs;
RWStructuredBuffer<uint> _ArgsInvalidPrimitiveIDs;
RWStructuredBuffer<uint> _ArgsResampling;

RWStructuredBuffer<int> _SortedPrimitiveIDs;
float3 _WorldSpaceCameraPos;
float _CameraFarZ;
float _CameraFovVRad;
int _MaxFragmentsPerPixel;
int _CurrentStochasticFrame;
RWStructuredBuffer<int> _PerPixelFragmentCounter;
RWStructuredBuffer<float4> _PerPixelFragmentList;
float _MeshSVBRDFMode;
int u_UniformModeDepth;

float3 _ColmapTrimAABBMin;
float3 _ColmapTrimAABBMax;

float _AlphaContributingCutoff;
float _DoGradientDescent;
float _DoStructuralLoss;
float _StructuralLossWeight;
float _StructuralLossDistFactor;
float _DoPixelCountNorm;



// ======================= RANDOM MUTATION OPTIMIZATION =======================
[numthreads(256, 1, 1)]
void ResetMutationLossAccumulation(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	// Reset primitive gradients
	_PrimitiveGradientsOptimStep[threadID] = ZeroInitPrimitiveData();

	// Reset primitive error
#ifdef PER_VERTEX_ERROR
	_PrimitiveMutationError[threadID * 3 + 0] = int3(0, 0, 0);
	_PrimitiveMutationError[threadID * 3 + 1] = int3(0, 0, 0);
	_PrimitiveMutationError[threadID * 3 + 2] = int3(0, 0, 0);
#else
	_PrimitiveMutationError[threadID] = int3(0, 0, 0);
#endif
}

void AccumulateLossForPixel(uint2 pixelCoord, uint flatPixelCoord, int lossDiff, Texture2D<float4> _DepthIDBuffer, inout int seenPrimitiveID, int avoidPrimitiveID = -1)
{
//#ifdef OPAQUE_RENDER
	float4 depthIDBufferFetch = _DepthIDBuffer[pixelCoord];
	int primitiveID = asuint(depthIDBufferFetch.r);
	seenPrimitiveID = primitiveID;
	if (primitiveID >= _PrimitiveCount || seenPrimitiveID == avoidPrimitiveID)
		return;
#ifdef PER_VERTEX_ERROR
	InterlockedAdd(_PrimitiveMutationError[primitiveID * 3 + 0].x, lossDiff);
	InterlockedAdd(_PrimitiveMutationError[primitiveID * 3 + 1].x, lossDiff);
	InterlockedAdd(_PrimitiveMutationError[primitiveID * 3 + 2].x, lossDiff);
	if (_DoPixelCountNorm > 0.5)
		InterlockedAdd(_PrimitiveMutationError[primitiveID * 3 + 0].y, 1);
#else
	InterlockedAdd(_PrimitiveMutationError[primitiveID].x, lossDiff);
	if (_DoPixelCountNorm > 0.5)
		InterlockedAdd(_PrimitiveMutationError[primitiveID].y, 1);
#endif

/*#elif SORTED_ALPHA_RENDER
	int visibleFragmentCount = _PerPixelFragmentCounter[flatPixelCoord];
	for (int i = 0; i < visibleFragmentCount; i++)
	{
		float4 depthIDBufferFetch = _PerPixelFragmentList[flatPixelCoord * _MaxFragmentsPerPixel + i];
		uint primitiveID = asuint(depthIDBufferFetch.r);
		InterlockedAdd(_PrimitiveMutationError[primitiveID].x, lossDiff);
	}

#elif STOCHASTIC_ALPHA_RENDER
	for (int i = 0; i < _MaxFragmentsPerPixel; i++)
	{
		float4 depthIDBufferFetch = _PerPixelFragmentList[flatPixelCoord * _MaxFragmentsPerPixel + i];
		uint primitiveID = asuint(depthIDBufferFetch.r);
		InterlockedAdd(_PrimitiveMutationError[primitiveID].x, lossDiff);
	}
#endif*/
}

[numthreads(16, 16, 1)]
void AccumulateMutationLoss(uint3 threadID : SV_DispatchThreadID)
{
	if (threadID.x >= _OutputWidth || threadID.y >= _OutputHeight)
		return;

	// Fetch target color, should already be alpha pre-multiplied
	uint2 pixelCoord = threadID.xy;
	uint flatPixelCoord = pixelCoord.y * _OutputWidth + pixelCoord.x;
	float2 pixelUV = (pixelCoord + 0.5) / float2(_OutputWidth, _OutputHeight);
	float4 targetColor = _TargetTexture.SampleLevel(_LinearClampSampler, pixelUV, 0);
	targetColor.rgb = pow(targetColor.rgb, 1.0 / 2.2) * targetColor.a;

	// Fetch pre (0) and post (1) random move result, should already by alpha pre-multiplied
	float4 colorRenderMinus = _ResolvedFrameMutatedMinus.SampleLevel(_LinearClampSampler, pixelUV, 0).rgba;
	float4 colorRenderPlus = _ResolvedFrameMutatedPlus.SampleLevel(_LinearClampSampler, pixelUV, 0).rgba;
	colorRenderMinus.rgb = pow(colorRenderMinus.rgb, 1.0 / 2.2) * colorRenderMinus.a;
	colorRenderPlus.rgb = pow(colorRenderPlus.rgb, 1.0 / 2.2) * colorRenderPlus.a;

	// Compute loss
	float4 lossMinusRGBA = pow(abs(targetColor - colorRenderMinus), _LossMode == 1 ? 2.0 : 1.0);
	float4 lossPlusRGBA = pow(abs(targetColor - colorRenderPlus), _LossMode == 1 ? 2.0 : 1.0);
	float lossMinus = lossMinusRGBA.x + lossMinusRGBA.y + lossMinusRGBA.z + lossMinusRGBA.a * _DoAlphaLoss * 1;
	float lossPlus = lossPlusRGBA.x + lossPlusRGBA.y + lossPlusRGBA.z + lossPlusRGBA.a * _DoAlphaLoss * 1;
	float lossDiffFloat = lossMinus - lossPlus;

	int lossDiff = lossDiffFloat * 65536 * 1;
	if (lossDiff == 0)
		return;

	// Accumulate loss for all primitives that contributed using both ID buffers
	int seenPrimitiveID1 = -1;
	int seenPrimitiveID2 = -1;
	AccumulateLossForPixel(pixelCoord, flatPixelCoord, lossDiff, _DepthIDBufferMutatedPlus, seenPrimitiveID1);
	AccumulateLossForPixel(pixelCoord, flatPixelCoord, lossDiff, _DepthIDBufferMutatedMinus, seenPrimitiveID2, seenPrimitiveID1);
}

[numthreads(256, 1, 1)]
void AccumulateMutationGradientsResetLoss(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;
	uint primitiveID = threadID;

	// Fetch normalized Primitive loss
#ifdef PER_VERTEX_ERROR
	float3 lossDiffImage = float3(_PrimitiveMutationError[primitiveID * 3 + 0].x, _PrimitiveMutationError[primitiveID * 3 + 1].x, _PrimitiveMutationError[primitiveID * 3 + 2].x);
	int pixelCountImage = _PrimitiveMutationError[primitiveID * 3 + 0].y;
	if (_DoPixelCountNorm > 0.5 && pixelCountImage > 0)
		lossDiffImage /= (float3)pixelCountImage;
	float3 lossDiff;
	if (_DoStructuralLoss > 0.5)
	{
		float3 lossDiffStructural = float3(_PrimitiveMutationError[primitiveID * 3 + 0].z, _PrimitiveMutationError[primitiveID * 3 + 1].z, _PrimitiveMutationError[primitiveID * 3 + 2].z);
		if (_DoPixelCountNorm > 0.5)
			lossDiffStructural /= (_ViewsPerOptimStep * _MutationsPerFrame);
		lossDiff = lossDiffImage * (1.0 - _StructuralLossWeight) + lossDiffStructural * _StructuralLossWeight;
	}
	else
	{
		lossDiff = lossDiffImage;
	}
#else
	float lossDiffImage = _PrimitiveMutationError[primitiveID].x;
	int pixelCountImage = _PrimitiveMutationError[primitiveID].y;
	if (_DoPixelCountNorm > 0.5 && pixelCountImage > 0)
		lossDiffImage /= (float)pixelCountImage;
	float lossDiff;
	if (_DoStructuralLoss > 0.5)
	{
		float lossDiffStructural = _PrimitiveMutationError[primitiveID].z;
		if (_DoPixelCountNorm > 0.5)
			lossDiffStructural /= (_ViewsPerOptimStep * _MutationsPerFrame);
		lossDiff = lossDiffImage * (1.0 - _StructuralLossWeight) + lossDiffStructural * _StructuralLossWeight;
	}
	else
	{
		lossDiff = lossDiffImage;
	}
#endif

	// Get data
	PrimitiveData primitiveData = _PrimitiveBuffer[primitiveID];
	PrimitiveData primitiveDataMutated = _PrimitiveBufferMutated[primitiveID];
	PrimitiveData mutationGradients = _PrimitiveGradientsOptimStep[primitiveID];

	// Convert to primitive agnostic float arrays
	float primitiveDataFloats[PRIMITIVE_SIZE];
	float primitiveDataMutatedFloats[PRIMITIVE_SIZE];
	float mutationGradientsFloats[PRIMITIVE_SIZE];
	GetPrimitiveAsFloatArray(primitiveData, primitiveDataFloats);
	GetPrimitiveAsFloatArray(primitiveDataMutated, primitiveDataMutatedFloats);
	GetPrimitiveAsFloatArray(mutationGradients, mutationGradientsFloats);

	// Accumulate gradients
	for (int i = 0; i < PRIMITIVE_SIZE; i++)
	{
#ifdef PER_VERTEX_ERROR
		float lossDiffToUse;
		if (i < 3)
			lossDiffToUse = lossDiff.x;
		else if (i < 6)
			lossDiffToUse = lossDiff.y;
		else if (i < 9)
			lossDiffToUse = lossDiff.z;
		else
			lossDiffToUse = (lossDiff.x + lossDiff.y + lossDiff.z) / 3.0;
#else
		float lossDiffToUse = lossDiff;
#endif
		float mutation = primitiveDataMutatedFloats[i] - primitiveDataFloats[i];
		mutationGradientsFloats[i] += mutation * lossDiffToUse / 2.0;
	}

	// Convert back to primitive struct
	mutationGradients = GetFloatArrayAsPrimitive(mutationGradientsFloats);

	// Store result
	_PrimitiveGradientsOptimStep[primitiveID] = mutationGradients;

	// Reset Primitive loss
#ifdef PER_VERTEX_ERROR
	_PrimitiveMutationError[threadID * 3 + 0] = int3(0, 0, 0);
	_PrimitiveMutationError[threadID * 3 + 1] = int3(0, 0, 0);
	_PrimitiveMutationError[threadID * 3 + 2] = int3(0, 0, 0);
#else
	_PrimitiveMutationError[threadID] = int3(0, 0, 0);
#endif
}

[numthreads(256, 1, 1)]
void ApplyRandomMutation(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	// Get data
	uint primitiveID = threadID;
	PrimitiveData primitiveData = _PrimitiveBuffer[primitiveID];
	PrimitiveData mutationGradients = _PrimitiveGradientsOptimStep[primitiveID];
	PrimitiveData gradientMoments1 = _PrimitiveGradientsMoments1[primitiveID];
	PrimitiveData gradientMoments2 = _PrimitiveGradientsMoments2[primitiveID];

	// Convert to primitive agnostic float arrays
	float primitiveDataFloats[PRIMITIVE_SIZE];
	float mutationGradientsFloats[PRIMITIVE_SIZE];
	float gradientMoments1Floats[PRIMITIVE_SIZE];
	float gradientMoments2Floats[PRIMITIVE_SIZE];
	float learningRatesFloats[PRIMITIVE_SIZE];
	GetPrimitiveAsFloatArray(primitiveData, primitiveDataFloats);
	GetPrimitiveAsFloatArray(mutationGradients, mutationGradientsFloats);
	GetPrimitiveAsFloatArray(gradientMoments1, gradientMoments1Floats);
	GetPrimitiveAsFloatArray(gradientMoments2, gradientMoments2Floats);
	GetLearningRatesFloatArray(learningRatesFloats);

	// Apply gradients
	if (_OptimizerMode == 0) // RMS PROP
	{
		for (int i = 0; i < PRIMITIVE_SIZE; i++)
		{
			if (learningRatesFloats[i] == 0)
				continue;

			// Fetch gradient
			float gradient = mutationGradientsFloats[i];

			// Update RMS Prop squared gradient
			gradientMoments1Floats[i] = _OptimizerBeta1 * gradientMoments1Floats[i] + (1.0 - _OptimizerBeta1) * (gradient * gradient);

			// Apply gradient
			if (_CurrentOptimStep == 0)
				continue;
			primitiveDataFloats[i] += learningRatesFloats[i] * (gradient / (sqrt(gradientMoments1Floats[i]) + 1e-7));
		}
	}
	else // ADAM
	{
		int primitiveOptimStep = _PrimitiveOptimStepCounter[primitiveID];
		for (int i = 0; i < PRIMITIVE_SIZE; i++)
		{
			if (learningRatesFloats[i] == 0)
				continue;

			// Fetch gradient
			float gradient = mutationGradientsFloats[i];

			// Update gradient moments
			gradientMoments1Floats[i] = _OptimizerBeta1 * gradientMoments1Floats[i] + (1.0 - _OptimizerBeta1) * gradient;
			gradientMoments2Floats[i] = _OptimizerBeta2 * gradientMoments2Floats[i] + (1.0 - _OptimizerBeta2) * (gradient * gradient);

			// Apply gradient
			float moment1BiasCorrected = gradientMoments1Floats[i] / (1.0 - pow(_OptimizerBeta1, primitiveOptimStep + 1));
			float moment2BiasCorrected = gradientMoments2Floats[i] / (1.0 - pow(_OptimizerBeta2, primitiveOptimStep + 1));
			if (_DoGradientDescent > 0.5)
				primitiveDataFloats[i] += learningRatesFloats[i] * (moment1BiasCorrected / (sqrt(moment2BiasCorrected) + 1e-7));
		}
		_PrimitiveOptimStepCounter[primitiveID] = primitiveOptimStep + 1;
	}

	// Convert back to primitive struct
	primitiveData = GetFloatArrayAsPrimitive(primitiveDataFloats);
	gradientMoments1 = GetFloatArrayAsPrimitive(gradientMoments1Floats);
	gradientMoments2 = GetFloatArrayAsPrimitive(gradientMoments2Floats);

	// Apply primitive specific clamping, normalizing, etc.
	PostProcessPrimitive(primitiveData);

	// Write results
	_PrimitiveBuffer[primitiveID] = primitiveData;
	_PrimitiveGradientsMoments1[primitiveID] = gradientMoments1;
	_PrimitiveGradientsMoments2[primitiveID] = gradientMoments2;
}

[numthreads(256, 1, 1)]
void CreateNewRandomMutation(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	// Get current primitive data
	PrimitiveData primitiveData = _PrimitiveBuffer[threadID];

	// Compute world space pixel size at primitive pos for current view point
	float3 centerPos = GetPrimitiveWorldDepthSortPosition(primitiveData.geometry);
	float d = length(centerPos - _WorldSpaceCameraPos);
	float screenSize = 2.0 * tan(_CameraFovVRad / 2.0) * d;
	float pixelSize = screenSize / (float)_OutputHeight;

	// Convert to primitive agnostic float arrays // TODO : remove
	float primitiveDataFloats[PRIMITIVE_SIZE];
	float learningRatesFloats[PRIMITIVE_SIZE];
	GetPrimitiveAsFloatArray(primitiveData, primitiveDataFloats);
	GetLearningRatesFloatArray(learningRatesFloats);

	uint rngState = WangHash((_CurrentFrame * _PrimitiveCount * _MutationsPerFrame) + (threadID * _MutationsPerFrame) + _CurrentMutation);
	for (int i = 0; i < PRIMITIVE_SIZE; i++)
	{
		if (learningRatesFloats[i] == 0)
			continue;
		float randomMutation = GetRandomFloat(rngState);
		randomMutation *= _IsAntitheticMutation > 0.5 ? -1.0 : 1.0;

		// Custom mutation magnitudes
		if (learningRatesFloats[i] == _LearningRatePosition || learningRatesFloats[i] == _LearningRateOffsets)
		{
			// Minimum pixel change considering current camera VP matrix
			//randomMutation *= pixelSize;
			//randomMutation *= 0.00001;
			randomMutation *= learningRatesFloats[i];
			primitiveDataFloats[i] += randomMutation;
		}
		else if(learningRatesFloats[i] == _LearningRateColor)
		{
			#ifdef SINGLE_COLOR
				// Minimum pixel change considering gamma target
				randomMutation *= (1.0 / 256.0);
				float temp = pow(primitiveDataFloats[i], 2.2) + randomMutation;
				primitiveDataFloats[i] = pow(temp, 1.0 / 2.2);
			#else
				randomMutation *= learningRatesFloats[i];
				primitiveDataFloats[i] += randomMutation;
			#endif
		}
		else if (learningRatesFloats[i] == _LearningRateEnvMap)
		{
			// Minimum pixel change considering gamma target
			randomMutation *= (1.0 / 256.0);
			float temp = pow(primitiveDataFloats[i], 2.2) + randomMutation;
			primitiveDataFloats[i] = pow(temp, 1.0 / 2.2);
		}
		else
		{
			randomMutation *= learningRatesFloats[i];
			primitiveDataFloats[i] += randomMutation;
		}

	}

	// Convert back to primitive struct
	primitiveData = GetFloatArrayAsPrimitive(primitiveDataFloats);

	// Apply primitive specific clamping, normalizing, etc.
	PostProcessPrimitive(primitiveData);

	// Store moved primitive for rendering
	_PrimitiveBufferMutated[threadID] = primitiveData;
}




// ======================= STRUCTURAL LOSS =======================
float3 ProjectPointOnLine(float3 A, float3 B, float3 P)
{
	float3 AB = B - A;
	float3 AP = P - A;
	float3 projection = dot(AP, AB) / dot(AB, AB) * AB;
	return A + projection;
}

float CustomBellFunction(float x, float sizeParam)
{
	float A = 20.0;
	float B = 5.0;
	float x2 = x / (sizeParam * B * 2.0);
	return A * x2 * exp(-B * x2);
}

float GaussianFunction(float x, float mu, float sigma, bool doNorm = true)
{
	float norm = 1.0 / (sigma * sqrt(2.0 * 3.1415));
	if (doNorm == false)
		norm = 1.0;
	return norm * exp(-pow(x - mu, 2.0) / pow(sigma, 2.0));
}

float VertexLossFunction(float distance, float gaussParam)
{
	//float loss = distance;
	float loss = sqrt(distance);
	//float loss = GaussianFunction(distance, gaussParam * 2.0, gaussParam / 2.0, false);
	//float loss = CustomBellFunction(distance, gaussParam);
	//loss = pow(loss, 2.0);
	return loss;
}

uint64_t Pack32UIntsTo64UInt(uint a, uint b)
{
	uint64_t res = (uint64_t(a) << 32) | b;
	return res;
}

void Unpack64UIntTo32UInts(uint64_t a, out uint b, out uint c)
{
	b = a >> 32;
	c = a & 0xFFFFFFFF;
}

[numthreads(256, 1, 1)]
void MaintainClosestEdgeNeighbours(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	int primitiveID = threadID;
	PrimitiveData current = _PrimitiveBuffer[primitiveID];
	float3 currentPositions[3];
	currentPositions[0] = GetWorldVertex(current.geometry, 0);
	currentPositions[1] = GetWorldVertex(current.geometry, 1);
	currentPositions[2] = GetWorldVertex(current.geometry, 2);
	float currentAvgSize = (length(currentPositions[0] - currentPositions[1]) + length(currentPositions[1] - currentPositions[2]) + length(currentPositions[2] - currentPositions[0])) / 3.0;
	float3 currentAvgPos = (currentPositions[0] + currentPositions[1] + currentPositions[1]) / 3.0;

	for (int i = 0; i < 3; i++)
	{
		// Fetch edge pairing data
		uint64_t packedDistAndID = _StructuralEdgeClosestNeighbourBuffer[threadID * 3 + i];
		uint dist, edgeID;
		Unpack64UIntTo32UInts(packedDistAndID, dist, edgeID);
		uint neighbourID = edgeID / 3;
		if (neighbourID > _PrimitiveCount)
			continue;

		int2 closestPair0 = int2((i + 0) % 3, -1);
		int2 closestPair1 = int2((i + 1) % 3, -1);
		uint neighbourEdge = edgeID % 3;
		if (neighbourEdge == 0)
		{
			closestPair0.y = 0;
			closestPair1.y = 1;
		}
		else if (neighbourEdge == 1)
		{
			closestPair0.y = 1;
			closestPair1.y = 2;
		}
		else
		{
			closestPair0.y = 2;
			closestPair1.y = 0;
		}

		// Fetch neighbour data
		PrimitiveData other = _PrimitiveBuffer[neighbourID];
		float3 otherPositions[3];
		otherPositions[0] = GetWorldVertex(other.geometry, 0);
		otherPositions[1] = GetWorldVertex(other.geometry, 1);
		otherPositions[2] = GetWorldVertex(other.geometry, 2);
		float otherAvgSize = (length(otherPositions[0] - otherPositions[1]) + length(otherPositions[1] - otherPositions[2]) + length(otherPositions[2] - otherPositions[0])) / 3.0;
		float3 otherAvgPos = (otherPositions[0] + otherPositions[1] + otherPositions[1]) / 3.0;

		// Check if distance isn't valid anymore
		if (length(currentAvgPos - otherAvgPos) > currentAvgSize * _StructuralLossDistFactor)
		{
			_StructuralEdgeClosestNeighbourBuffer[threadID * 3 + i] = 0xFFFFFFFFFFFFFFFF;
		}
	}
}

[numthreads(16, 16, 1)]
void UpdateClosestEdgeNeighbours(uint3 threadID : SV_DispatchThreadID)
{
	if (threadID.x >= _OutputWidth || threadID.y >= _OutputHeight)
		return;

	// Fetch seen primitive
	uint2 pixelCoord = threadID.xy;
	uint flatPixelCoord = pixelCoord.y * _OutputWidth + pixelCoord.x;
	float4 depthIDBufferFetch = _DepthIDBufferMutatedPlus[pixelCoord]; // TODO: plus or minus ?
	int primitiveID = asuint(depthIDBufferFetch.r);
	if (primitiveID >= _PrimitiveCount)
		return;

	PrimitiveData current = _PrimitiveBuffer[primitiveID];
	float3 currentPositions[3];
	currentPositions[0] = GetWorldVertex(current.geometry, 0);
	currentPositions[1] = GetWorldVertex(current.geometry, 1);
	currentPositions[2] = GetWorldVertex(current.geometry, 2);
	PrimitiveData currentMutated = _PrimitiveBufferMutated[primitiveID];
	float3 currentMutatedPositions[3];
	currentMutatedPositions[0] = GetWorldVertex(currentMutated.geometry, 0);
	currentMutatedPositions[1] = GetWorldVertex(currentMutated.geometry, 1);
	currentMutatedPositions[2] = GetWorldVertex(currentMutated.geometry, 2);
	float currentAvgSize = (length(currentPositions[0] - currentPositions[1]) + length(currentPositions[1] - currentPositions[2]) + length(currentPositions[2] - currentPositions[0])) / 3.0;
	float3 currentAvgPos = (currentPositions[0] + currentPositions[1] + currentPositions[1]) / 3.0;

	// Find a neighbouring triangle in pixel neighbours (use only first one found)
	int neighbourID = -1;
	for (int y = -1; y <= 1; y++)
	{
		for (int x = -1; x <= 1; x++)
		{
			if (x == 0 && y == 0)
				continue;

			// Check for valid primitive
			uint2 otherPixelCoord = clamp(pixelCoord + int2(x, y), int2(0, 0), int2(_OutputWidth, _OutputHeight));
			float4 otherDepthIDBufferFetch = _DepthIDBufferMutatedPlus[otherPixelCoord];
			int otherPrimitiveID = asuint(otherDepthIDBufferFetch.r);
			if (otherPrimitiveID < _PrimitiveCount && otherPrimitiveID != primitiveID)
			{
				neighbourID = otherPrimitiveID;
				break;
			}
		}
		if (neighbourID != -1)
			break;
	}
	if (neighbourID == -1)
		return;

	// Get neighbour data
	PrimitiveData other = _PrimitiveBuffer[neighbourID];
	float3 otherPositions[3];
	otherPositions[0] = GetWorldVertex(other.geometry, 0);
	otherPositions[1] = GetWorldVertex(other.geometry, 1);
	otherPositions[2] = GetWorldVertex(other.geometry, 2);
	float otherAvgSize = (length(otherPositions[0] - otherPositions[1]) + length(otherPositions[1] - otherPositions[2]) + length(otherPositions[2] - otherPositions[0])) / 3.0;
	float3 otherAvgPos = (otherPositions[0] + otherPositions[1] + otherPositions[1]) / 3.0;

	// Return if triangles are too far away
	if (length(currentAvgPos - otherAvgPos) > currentAvgSize * _StructuralLossDistFactor)
		return;

	// Find closest avilable edge pairing between the two triangles
	float closestEdgePairingDist = 99999999;
	int2 closestEdgePairing = int2(-1, -1);
	for (int i = 0; i < 3; i++)
	{
		float3 currentPosA = currentPositions[(i + 0) % 3];
		float3 currentPosB = currentPositions[(i + 1) % 3];
		for (int j = 0; j < 3; j++)
		{
			float3 otherPosA = otherPositions[(j + 0) % 3];
			float3 otherPosB = otherPositions[(j + 1) % 3];
			float pairingDist = min(length(currentPosA - otherPosA) + length(currentPosB - otherPosB), length(currentPosA - otherPosB) + length(currentPosB - otherPosA));
			uint pairingDistInt = pairingDist * 65536;

			// Fetch edge pairing data
			uint64_t packedDistAndID = _StructuralEdgeClosestNeighbourBuffer[neighbourID * 3 + j];
			uint otherPairingDist, otherPairedEdgeID;
			Unpack64UIntTo32UInts(packedDistAndID, otherPairingDist, otherPairedEdgeID);

			//if (pairingDist < closestEdgePairingDist && (otherPairedEdgeID > _PrimitiveCount * 3 || pairingDistInt < otherPairingDist))
			//if (pairingDist < closestEdgePairingDist && otherPairedEdgeID > _PrimitiveCount * 3)
			if (pairingDist < closestEdgePairingDist)
			{
				closestEdgePairingDist = pairingDist;
				closestEdgePairing = int2(i, j);
			}
		}
	}

	// Update stored closest edge pairing
	uint currentEdgeID = primitiveID * 3 + closestEdgePairing.x;
	uint otherEdgeID = neighbourID * 3 + closestEdgePairing.y;
	uint pairingDist = closestEdgePairingDist * 65536;
	uint64_t dummy;
	uint64_t packedDistAndID = Pack32UIntsTo64UInt(pairingDist, otherEdgeID);
	InterlockedMin(_StructuralEdgeClosestNeighbourBuffer[currentEdgeID], packedDistAndID, dummy);
	//uint64_t packedDistAndIDForOther = Pack32UIntsTo64UInt(pairingDist, currentEdgeID);
	//InterlockedMin(_StructuralEdgeClosestNeighbourBuffer[otherEdgeID], packedDistAndIDForOther, dummy);
}

[numthreads(256, 1, 1)]
void AccumulateMutationLossStructural(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	int primitiveID = threadID;
	PrimitiveData current = _PrimitiveBuffer[primitiveID];
	float3 currentPositions[3];
	currentPositions[0] = GetWorldVertex(current.geometry, 0);
	currentPositions[1] = GetWorldVertex(current.geometry, 1);
	currentPositions[2] = GetWorldVertex(current.geometry, 2);
	PrimitiveData currentMutated = _PrimitiveBufferMutated[primitiveID];
	float3 currentMutatedPositions[3];
	currentMutatedPositions[0] = GetWorldVertex(currentMutated.geometry, 0);
	currentMutatedPositions[1] = GetWorldVertex(currentMutated.geometry, 1);
	currentMutatedPositions[2] = GetWorldVertex(currentMutated.geometry, 2);
	float currentAvgSize = (length(currentPositions[0] - currentPositions[1]) + length(currentPositions[1] - currentPositions[2]) + length(currentPositions[2] - currentPositions[0])) / 3.0;
	float3 currentAvgPos = (currentPositions[0] + currentPositions[1] + currentPositions[1]) / 3.0;

	for (int i = 0; i < 3; i++)
	{
		// Fetch edge pairing data
		uint64_t packedDistAndID = _StructuralEdgeClosestNeighbourBuffer[threadID * 3 + i];
		uint dist, edgeID;
		Unpack64UIntTo32UInts(packedDistAndID, dist, edgeID);
		uint neighbourID = edgeID / 3;
		if (neighbourID > _PrimitiveCount)
			continue;

		int2 closestPair0 = int2((i + 0) % 3, -1);
		int2 closestPair1 = int2((i + 1) % 3, -1);
		uint neighbourEdge = edgeID % 3;
		if (neighbourEdge == 0)
		{
			closestPair0.y = 0;
			closestPair1.y = 1;
		}
		else if (neighbourEdge == 1)
		{
			closestPair0.y = 1;
			closestPair1.y = 2;
		}
		else
		{
			closestPair0.y = 2;
			closestPair1.y = 0;
		}

		// Fetch neighbour data
		PrimitiveData other = _PrimitiveBuffer[neighbourID];
		float3 otherPositions[3];
		otherPositions[0] = GetWorldVertex(other.geometry, 0);
		otherPositions[1] = GetWorldVertex(other.geometry, 1);
		otherPositions[2] = GetWorldVertex(other.geometry, 2);

		// Flip pairing if reversed closest distances (we don't store that data)
		if (length(currentPositions[closestPair0.x] - otherPositions[closestPair1.y]) < length(currentPositions[closestPair0.x] - otherPositions[closestPair0.y]))
		{
			int temp = closestPair0.y;
			closestPair0.y = closestPair1.y;
			closestPair1.y = temp;
		}

		// Edge pairing distances
		float length0Minus, length0Plus; // Vertex pairing 0
		{
			int i = closestPair0.x;
			int j = closestPair0.y;
			float3 mutation = currentMutatedPositions[i] - currentPositions[i];
			float3 vertexPlus = currentPositions[i] + mutation;
			float3 vertexMinus = currentPositions[i] - mutation;
			float3 otherVertex = otherPositions[j];
			length0Minus = length(otherPositions[j] - vertexMinus);
			length0Plus = length(otherPositions[j] - vertexPlus);
		}
		float length1Minus, length1Plus; // Vertex pairing 1
		{
			int i = closestPair1.x;
			int j = closestPair1.y;
			float3 mutation = currentMutatedPositions[i] - currentPositions[i];
			float3 vertexPlus = currentPositions[i] + mutation;
			float3 vertexMinus = currentPositions[i] - mutation;
			float3 otherVertex = otherPositions[j];
			length1Minus = length(otherPositions[j] - vertexMinus);
			length1Plus = length(otherPositions[j] - vertexPlus);
		}

		float length2Minus, length2Plus, lossLength; // Third vertices pairing
		{
			int i = (closestPair0.x == 0 || closestPair1.x == 0) ? (closestPair0.x == 1 || closestPair1.x == 1) ? 2 : 1 : 0;
			int j = (closestPair0.y == 0 || closestPair1.y == 0) ? (closestPair0.y == 1 || closestPair1.y == 1) ? 2 : 1 : 0;
			float3 mutation = currentMutatedPositions[i] - currentPositions[i];
			float3 vertexPlus = currentPositions[i] + mutation;
			float3 vertexMinus = currentPositions[i] - mutation;
			float3 otherVertex = otherPositions[j];
			float3 lineDir = normalize(otherPositions[closestPair1.y] - otherPositions[closestPair0.y]);
			length2Minus = length(ProjectPointOnLine(otherVertex, otherVertex + lineDir, vertexMinus) - vertexMinus);
			length2Plus = length(ProjectPointOnLine(otherVertex, otherVertex + lineDir, vertexPlus) - vertexPlus);
			lossLength = length(ProjectPointOnLine(otherPositions[closestPair0.y], otherPositions[closestPair1.y], otherVertex) - otherVertex);
		}

#ifdef PER_VERTEX_ERROR
		// Attract closest pairs to form an edge
		float lossMinus0 = VertexLossFunction(length0Minus, currentAvgSize);
		float lossPlus0 = VertexLossFunction(length0Plus, currentAvgSize);
		float lossMinus1 = VertexLossFunction(length1Minus, currentAvgSize);
		float lossPlus1 = VertexLossFunction(length1Plus, currentAvgSize);

		// Force third vertices to be on opposite sides of the pairing line
		float lossMinus2 = pow(1.0 - min(length2Minus, lossLength) / lossLength, 2.0);
		float lossPlus2 = pow(1.0 - min(length2Plus, lossLength) / lossLength, 2.0);

		// Accumulate per vertex loss
		float lossDiff0 = lossMinus0 - lossPlus0;
		float lossDiff1 = lossMinus1 - lossPlus1;
		float lossDiff2 = lossMinus2 - lossPlus2;
		float3 accumulateLossDiff = float3(lossDiff0, lossDiff1, lossDiff2) * 65536;

		int thirdVertex = (closestPair0.x == 0 || closestPair1.x == 0) ? (closestPair0.x == 1 || closestPair1.x == 1) ? 2 : 1 : 0;
		_PrimitiveMutationError[primitiveID * 3 + closestPair0.x].z += accumulateLossDiff.x;
		_PrimitiveMutationError[primitiveID * 3 + closestPair1.x].z += accumulateLossDiff.y;
		_PrimitiveMutationError[primitiveID * 3 + thirdVertex].z += accumulateLossDiff.z;
#else
		// Attract closest pairs to form an edge
		float lengthMinus = length0Minus + length1Minus;
		float lengthPlus = length0Plus + length1Plus;
		float lossMinus = VertexLossFunction(lengthMinus, currentAvgSize);
		float lossPlus = VertexLossFunction(lengthPlus, currentAvgSize);

		// Force third vertices to be on opposite sides of the pairing line
		float lossMinus2 = pow(1.0 - min(length2Minus, lossLength) / lossLength, 2.0);
		float lossPlus2 = pow(1.0 - min(length2Plus, lossLength) / lossLength, 2.0);

		// Accumulate total loss
		float lossDiff = (lossMinus + lossMinus2) - (lossPlus + lossPlus2);
		float accumulateLossDiff = lossDiff * 65536;
		_PrimitiveMutationError[primitiveID].z += accumulateLossDiff;
#endif
	}
}

[numthreads(256, 1, 1)]
void WeldVertices(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	// WELD VERTICES
	/*float weldThreshold = length(currentPositions[closestPair0.x] - currentPositions[closestPair1.x]) * 0.1;
	if (length(currentPositions[closestPair0.x] - otherPositions[closestPair0.y]) < weldThreshold
		&& length(currentPositions[closestPair1.x] - otherPositions[closestPair1.y]) < weldThreshold)
	{
		// Weld pair 0
		int outValue;
		int2 pair0IDs = int2(primitiveID * 3 + closestPair0.x, closestNeighbour * 3 + closestPair0.y);
		InterlockedMin(_StructuralVertexWeldingBuffer[pair0IDs.x], _StructuralVertexWeldingBuffer[pair0IDs.y], outValue);
		InterlockedMin(_StructuralVertexWeldingBuffer[pair0IDs.y], _StructuralVertexWeldingBuffer[pair0IDs.x], outValue);

		// Weld pair 1
		int2 pair1IDs = int2(primitiveID * 3 + closestPair1.x, closestNeighbour * 3 + closestPair1.y);
		InterlockedMin(_StructuralVertexWeldingBuffer[pair1IDs.x], _StructuralVertexWeldingBuffer[pair1IDs.y], outValue);
		InterlockedMin(_StructuralVertexWeldingBuffer[pair1IDs.y], _StructuralVertexWeldingBuffer[pair1IDs.x], outValue);
	}
	else*/
}




// ========================= ENV MAP SPECIFIC =========================
RWStructuredBuffer<float3> _PrimitiveBufferFloat3;
RWStructuredBuffer<float3> _PrimitiveBufferMutatedFloat3;
RWStructuredBuffer<float3> _PrimitiveGradientsOptimStepFloat3;
RWStructuredBuffer<float3> _PrimitiveGradientsMoments1Float3;
RWStructuredBuffer<float3> _PrimitiveGradientsMoments2Float3;

[numthreads(256, 1, 1)]
void EnvMapResetMutationLossAccumulation(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _EnvMapResolution * _EnvMapResolution)
		return;

	// Reset primitive gradients
	_PrimitiveGradientsOptimStepFloat3[threadID] = float3(0, 0, 0);

	// Reset primitive loss (need it here for binary mutation mode)
	_PrimitiveMutationError[threadID] = 0;
}

[numthreads(16, 16, 1)]
void EnvMapAccumulateMutationLoss(uint3 threadID : SV_DispatchThreadID)
{
	if (threadID.x >= _OutputWidth || threadID.y >= _OutputHeight)
		return;

	// Fetch target color, should already be alpha pre-multiplied
	uint2 pixelCoord = threadID.xy;
	uint flatPixelCoord = pixelCoord.y * _OutputWidth + pixelCoord.x;
	float2 pixelUV = (pixelCoord + 0.5) / float2(_OutputWidth, _OutputHeight);
	float4 targetColor = _TargetTexture.SampleLevel(_LinearClampSampler, pixelUV, 0);
	targetColor.rgb = pow(targetColor.rgb, 1.0 / 2.2);// *targetColor.a;

	// Fetch pre (0) and post (1) random move result, should already by alpha pre-multiplied
	float4 colorRenderMinus = _ResolvedFrameMutatedMinus.SampleLevel(_LinearClampSampler, pixelUV, 0).rgba;
	float4 colorRenderPlus = _ResolvedFrameMutatedPlus.SampleLevel(_LinearClampSampler, pixelUV, 0).rgba;
	colorRenderMinus.rgb = pow(colorRenderMinus.rgb, 1.0 / 2.2);// *colorRenderMinus.a;
	colorRenderPlus.rgb = pow(colorRenderPlus.rgb, 1.0 / 2.2);// *colorRenderPlus.a;

	// Compute loss
	float4 lossMinusRGBA = pow(abs(targetColor - colorRenderMinus), 2.0); // L2
	float4 lossPlusRGBA = pow(abs(targetColor - colorRenderPlus), 2.0); // L2
	float lossMinus = lossMinusRGBA.x + lossMinusRGBA.y + lossMinusRGBA.z + lossMinusRGBA.a * _DoAlphaLoss;
	float lossPlus = lossPlusRGBA.x + lossPlusRGBA.y + lossPlusRGBA.z + lossPlusRGBA.a * _DoAlphaLoss;
	float lossDiffFloat = lossMinus - lossPlus;

	int lossDiff = lossDiffFloat * 65536;
	if (lossDiff == 0)
		return;

	// Accumulate loss for envmap using both ID buffers
	float4 depthIDBufferFetchPlus = _DepthIDBufferMutatedPlus[pixelCoord];
	float4 depthIDBufferFetchMinus = _DepthIDBufferMutatedMinus[pixelCoord];
	int seenEnvMapTexelID1 = -1;
	int seenEnvMapTexelID2 = -1;
	if (asuint(depthIDBufferFetchPlus.x) == 4294967295)
	{
		float3 worldViewDir = FloatToFloat3(depthIDBufferFetchPlus.y);
		float2 pixelUV = SimpleMapping(worldViewDir.xyz);
		int2 envMapCoord = clamp(pixelUV * _EnvMapResolution, 0, _EnvMapResolution - 1);
		seenEnvMapTexelID1 = envMapCoord.y * _EnvMapResolution + envMapCoord.x;
		InterlockedAdd(_PrimitiveMutationError[seenEnvMapTexelID1].x, lossDiff);
		InterlockedAdd(_PrimitiveMutationError[seenEnvMapTexelID1].y, 1);
	}
	if (asuint(depthIDBufferFetchMinus.x) == 4294967295)
	{
		float3 worldViewDir = FloatToFloat3(depthIDBufferFetchMinus.y);
		float2 pixelUV = SimpleMapping(worldViewDir.xyz);
		int2 envMapCoord = clamp(pixelUV * _EnvMapResolution, 0, _EnvMapResolution - 1);
		seenEnvMapTexelID2 = envMapCoord.y * _EnvMapResolution + envMapCoord.x;
		if (seenEnvMapTexelID2 != seenEnvMapTexelID1)
		{
			InterlockedAdd(_PrimitiveMutationError[seenEnvMapTexelID2].x, lossDiff);
			InterlockedAdd(_PrimitiveMutationError[seenEnvMapTexelID2].y, 1);
		}
	}
}

[numthreads(256, 1, 1)]
void EnvMapAccumulateMutationGradientsResetLoss(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _EnvMapResolution * _EnvMapResolution)
		return;
	uint primitiveID = threadID;

	// Fetch Primitive loss
	float lossDiff = _PrimitiveMutationError[primitiveID].x;

	// Get data
	float3 primitiveData = _PrimitiveBufferFloat3[primitiveID];
	float3 primitiveDataMutated = _PrimitiveBufferMutatedFloat3[primitiveID];
	float3 mutationGradients = _PrimitiveGradientsOptimStepFloat3[primitiveID];

	// Accumulate gradients
	float3 mutation = primitiveDataMutated - primitiveData;
	mutationGradients += mutation * lossDiff / 2.0;

	// Store result
	_PrimitiveGradientsOptimStepFloat3[primitiveID] = mutationGradients;

	// Reset Primitive loss
	_PrimitiveMutationError[threadID].x = 0;
}

[numthreads(256, 1, 1)]
void EnvMapApplyRandomMutation(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _EnvMapResolution * _EnvMapResolution)
		return;

	// Get data
	uint primitiveID = threadID;
	float3 primitiveData = _PrimitiveBufferFloat3[primitiveID];
	float3 mutationGradients = _PrimitiveGradientsOptimStepFloat3[primitiveID];
	float3 gradientMoments1 = _PrimitiveGradientsMoments1Float3[primitiveID];
	float3 gradientMoments2 = _PrimitiveGradientsMoments2Float3[primitiveID];
	float learningRates = _LearningRateEnvMap;
	if (learningRates == 0)
		return;

	// Normalize gradients by pixel counts and reset them
	int pixelCount = _PrimitiveMutationError[threadID].y;
	if (pixelCount > 0)
		mutationGradients /= (float)pixelCount;
	_PrimitiveMutationError[threadID].y = 0;

	// Apply gradients
	if (_OptimizerMode == 0) // RMS PROP
	{
		// Fetch gradient
		float3 gradient = mutationGradients;

		// Update RMS Prop squared gradient
		gradientMoments1 = _OptimizerBeta1 * gradientMoments1 + (1.0 - _OptimizerBeta1) * (gradient * gradient);

		// Apply gradient
		if (_CurrentOptimStep == 0)
			return;
		primitiveData += learningRates * (gradient / (sqrt(gradientMoments1) + 1e-7));
	}
	else // ADAM
	{
		int primitiveOptimStep = _PrimitiveOptimStepCounter[primitiveID];

		// Fetch gradient
		float3 gradient = mutationGradients;

		// Update gradient moments
		gradientMoments1 = _OptimizerBeta1 * gradientMoments1 + (1.0 - _OptimizerBeta1) * gradient;
		gradientMoments2 = _OptimizerBeta2 * gradientMoments2 + (1.0 - _OptimizerBeta2) * (gradient * gradient);

		// Apply gradient
		float3 moment1BiasCorrected = gradientMoments1 / (1.0 - pow(_OptimizerBeta1, primitiveOptimStep + 1));
		float3 moment2BiasCorrected = gradientMoments2 / (1.0 - pow(_OptimizerBeta2, primitiveOptimStep + 1));
		if (_DoGradientDescent > 0.5)
			primitiveData += learningRates * (moment1BiasCorrected / (sqrt(moment2BiasCorrected) + 1e-7));
		_PrimitiveOptimStepCounter[primitiveID] = primitiveOptimStep + 1;
	}

	// Apply primitive specific clamping, normalizing, etc.
	PostProcessEnvMap(primitiveData);

	// Write results
	_PrimitiveBufferFloat3[primitiveID] = primitiveData;
	_PrimitiveGradientsMoments1Float3[primitiveID] = gradientMoments1;
	_PrimitiveGradientsMoments2Float3[primitiveID] = gradientMoments2;
}

[numthreads(256, 1, 1)]
void EnvMapCreateNewRandomMutation(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _EnvMapResolution * _EnvMapResolution)
		return;

	// Get current primitive data
	float3 primitiveData = _PrimitiveBufferFloat3[threadID];
	float learningRates = _LearningRateColor;
	if (learningRates == 0)
		return;

	uint rngState = WangHash((_CurrentFrame * _PrimitiveCount * _MutationsPerFrame) + (threadID * _MutationsPerFrame) + _CurrentMutation);
	float3 randomMutation = float3(GetRandomFloat(rngState), GetRandomFloat(rngState), GetRandomFloat(rngState));
	randomMutation *= _IsAntitheticMutation > 0.5 ? -1.0 : 1.0;
	randomMutation *= learningRates;
	primitiveData += randomMutation;

	// Apply primitive specific clamping, normalizing, etc.
	PostProcessEnvMap(primitiveData);

	// Store moved primitive for rendering
	_PrimitiveBufferMutatedFloat3[threadID] = primitiveData;
}




// ======================= PRIMITIVE RESAMPLING =======================
[numthreads(256, 1, 1)]
void ResetVisibilityCounter(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;
	_PrimitiveKillCounters[threadID] = _FramesUnseenBeforeKill;
}

[numthreads(256, 1, 1)]
void DecrementVisibilityCounter(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;

	int currentCounter = _PrimitiveKillCounters[threadID];
	if (currentCounter > 0)
		_PrimitiveKillCounters[threadID] = currentCounter - 1;
}

[numthreads(256, 1, 1)]
void ListValidAndInvalidPrimitiveIDs(uint3 id : SV_DispatchThreadID)
{
	uint threadID = id.x + _Dispatch1DOffset;
	if (threadID >= _PrimitiveCount)
		return;
	uint primitiveID = threadID;// (threadID + _CurrentPairingOffset) % _PrimitiveCount;

	PrimitiveData primitiveData = _PrimitiveBuffer[primitiveID];
	float primitiveArea;
	bool isValid = PrimitiveIsValid(primitiveData, primitiveArea, _MinPrimitiveWorldArea);

	// Do skybox removal test
	/*PrimitiveData gradients = _PrimitiveGradientsMoments1[primitiveID];
	float posGradientMagnitude = gradients.positions[0].x + gradients.positions[0].y + gradients.positions[0].z + gradients.positions[1].x + gradients.positions[1].y + gradients.positions[1].z + gradients.positions[2].x + gradients.positions[2].y + gradients.positions[2].z;
	if (posGradientMagnitude > 10)
		isValid = false;*/

	// Do bounds trimming test
	/*bool doSubdivide = true;
	float3 pos = (primitiveData.positions[0] + primitiveData.positions[1] + primitiveData.positions[2]) / 3.0f;
	if ((pos.x > _ColmapTrimAABBMin.x && pos.x < _ColmapTrimAABBMax.x &&
		pos.y > _ColmapTrimAABBMin.y && pos.y < _ColmapTrimAABBMax.y &&
		pos.z > _ColmapTrimAABBMin.z && pos.z < _ColmapTrimAABBMax.z) == false)
	{
		doSubdivide = false;
	}*/

	// Random removal test
	/*float rand = WangHash((_CurrentFrame * _PrimitiveCount) + threadID) * (1.0 / 4294967296.0);
	if (rand < 0.1)
		isValid = false;*/

	// Do wrongly placed removal test
	/*PrimitiveData gradients = _PrimitiveGradientsMoments2[primitiveID];
	float colorGradientMagnitude = gradients.color.sh0.r + gradients.color.sh0.g + gradients.color.sh0.b;
	if (colorGradientMagnitude > 2000 && _PrimitiveOptimStepCounter[primitiveID] > 100)
		isValid = false;*/

	// Take into account visibility
//#ifdef OPAQUE_RENDER
	isValid = isValid && _PrimitiveKillCounters[primitiveID] > 0;
//#endif

	if (isValid == true)
	{
		// Primitive to subdivide must be twice larger than minimum area
		if (primitiveArea >= _MinPrimitiveWorldArea * 3.0)
			_AppendValidPrimitiveIDs.Append(primitiveID);
	}
	else
	{
		_AppendInvalidPrimitiveIDs.Append(primitiveID);
		// DEBUG : paint non-validity
		//_PrimitiveBuffer[primitiveID].color = uint4(256, 0, 256, 0);
	}
}

[numthreads(1, 1, 1)]
void InitArgsResampling(uint3 id : SV_DispatchThreadID)
{
	uint validCount = _ArgsValidPrimitiveIDs[0];
	uint invalidCount = _ArgsInvalidPrimitiveIDs[0];
	uint threadCount = min(validCount, invalidCount);
	if (_DoStructuralLoss > 0.5) // Triple resampling when using structural loss
		threadCount = min(validCount, invalidCount / 2);

	int threadGroupCount = (int)ceil(threadCount / 256.0);
	if (threadGroupCount < 65536)
	{
		_ArgsResampling[0] = threadGroupCount;
		_ArgsResampling[1] = 1;
		_ArgsResampling[2] = 1;
		_ArgsResampling[3] = threadCount;
	}
	else
	{
		int threadGroupCountDistributed = (int)ceil(pow(threadGroupCount, 1.0f / 2.0f));
		_ArgsResampling[0] = threadGroupCountDistributed;
		_ArgsResampling[1] = threadGroupCountDistributed;
		_ArgsResampling[2] = 1;
		_ArgsResampling[3] = threadCount;
	}
}

[numthreads(256, 1, 1)]
void InitBitonicSortValidPrimitives(uint threadID : SV_DispatchThreadID)
{
	if (threadID >= _PrimitiveCountPow2)
		return;

	uint validCount = _ArgsValidPrimitiveIDs[0];
	uint2 sort;
	if (threadID < validCount)
	{
		sort.x = _ReadValidPrimitiveIDs[threadID];

		// Sort : biggest first
		PrimitiveData primitiveData = _PrimitiveBuffer[sort.x];
		sort.y = GetTriangleArea(primitiveData.geometry) * 65536;

		// Sort : most color gardient variance first
		PrimitiveData primitiveGradients = _PrimitiveGradientsMoments2[sort.x];
		#ifdef TRIANGLE_GRADIENT
			float colorGradientVariance = SumColorFloats(primitiveGradients.colors[0]) + SumColorFloats(primitiveGradients.colors[1]) + SumColorFloats(primitiveGradients.colors[2]);
		#else
			float colorGradientVariance = SumColorFloats(primitiveGradients.color);
		#endif
		//sort.y = colorGradientVariance * 65536;

		// Sort : random
		//sort.y = WangHash((_CurrentOptimStep * _PrimitiveCount) + sort.x);
	}
	else
	{
		sort.x = 4294967295;
		sort.y = 0;
	}
	_SortedValidPrimitiveIDs[threadID.x] = sort;
}

[numthreads(256, 1, 1)]
void BitonicSortValidPrimitives(uint threadID : SV_DispatchThreadID)
{
	if (threadID >= _PrimitiveCountPow2 / 2)
		return;

	uint d1 = _SortLoopValueX;
	uint d2 = _SortLoopValueY;
	uint mask = 0xFFFFFFFEu * d1;
	uint i1 = ((threadID << 1) & mask) | (threadID & ~(mask >> 1));
	uint i2 = i1 | d1;

	uint2 gaussian1 = _SortedValidPrimitiveIDs[i1];
	uint2 gaussian2 = _SortedValidPrimitiveIDs[i2];
	uint2 minValue = gaussian1.y >= gaussian2.y ? gaussian1 : gaussian2;
	uint2 maxValue = gaussian1.y >= gaussian2.y ? gaussian2 : gaussian1;

	if ((threadID & d2) == 0u)
	{
		_SortedValidPrimitiveIDs[i1] = minValue;
		_SortedValidPrimitiveIDs[i2] = maxValue;
	}
	else
	{
		_SortedValidPrimitiveIDs[i1] = maxValue;
		_SortedValidPrimitiveIDs[i2] = minValue;
	}
}

[numthreads(256, 1, 1)]
void PairResampling(uint3 id : SV_DispatchThreadID)
{
	uint dispatchDistributer = _ArgsResampling[0];
	uint threadID = id.x + id.y * dispatchDistributer * 256;
	if (threadID >= _ArgsResampling[3])
		return;

	// Get current resampling pair (subdivide primitive1 by re-using primitive0)
	uint primitiveID0 = _ReadInvalidPrimitiveIDs[threadID];
	//uint primitiveID1 = _ReadValidPrimitiveIDs[threadID];
	uint primitiveID1 = _SortedValidPrimitiveIDs[threadID].x;
	if (primitiveID1 >= _PrimitiveCount)
		return;
	PrimitiveData primitive0 = _PrimitiveBuffer[primitiveID0];
	PrimitiveData primitive1 = _PrimitiveBuffer[primitiveID1];
	float3 primitive1Positions[3];
	primitive1Positions[0] = GetWorldVertex(primitive1.geometry, 0);
	primitive1Positions[1] = GetWorldVertex(primitive1.geometry, 1);
	primitive1Positions[2] = GetWorldVertex(primitive1.geometry, 2);

	// Longest edge bisection
	float lengthA = length(primitive1Positions[1] - primitive1Positions[0]);
	float lengthB = length(primitive1Positions[2] - primitive1Positions[1]);
	float lengthC = length(primitive1Positions[0] - primitive1Positions[2]);
	uint idBase, idLeft, idRight;
	if (lengthA > lengthB && lengthA > lengthC)
	{
		idBase = 2;
		idLeft = 0;
		idRight = 1;
	}
	else if (lengthB > lengthA && lengthB > lengthC)
	{
		idBase = 0;
		idLeft = 1;
		idRight = 2;
	}
	else
	{
		idBase = 1;
		idLeft = 2;
		idRight = 0;
	}

	// Handle kill counters
	_PrimitiveKillCounters[primitiveID0] = _FramesUnseenBeforeKill;
	_PrimitiveKillCounters[primitiveID1] = _FramesUnseenBeforeKill;

	// GEOMETRY
#ifdef ALTERNATE_POSITIONS
	_PrimitiveBuffer[primitiveID0].geometry.position = primitive1.geometry.position;
	_PrimitiveBuffer[primitiveID0].geometry.rotation = primitive1.geometry.rotation;
	float2 newOffset = (primitive1.geometry.offsets[idLeft] + primitive1.geometry.offsets[idRight]) / 2.0;
	_PrimitiveBuffer[primitiveID0].geometry.offsets[0] = primitive1.geometry.offsets[idBase];
	_PrimitiveBuffer[primitiveID0].geometry.offsets[1] = primitive1.geometry.offsets[idLeft];
	_PrimitiveBuffer[primitiveID0].geometry.offsets[2] = newOffset;
	_PrimitiveBuffer[primitiveID1].geometry.offsets[0] = primitive1.geometry.offsets[idBase];
	_PrimitiveBuffer[primitiveID1].geometry.offsets[1] = newOffset;
	_PrimitiveBuffer[primitiveID1].geometry.offsets[2] = primitive1.geometry.offsets[idRight];
#else
	float3 newVertex = (primitive1Positions[idLeft] + primitive1Positions[idRight]) / 2.0;
	_PrimitiveBuffer[primitiveID0].geometry.positions[0] = primitive1Positions[idBase];
	_PrimitiveBuffer[primitiveID0].geometry.positions[1] = primitive1Positions[idLeft];
	_PrimitiveBuffer[primitiveID0].geometry.positions[2] = newVertex;
	_PrimitiveBuffer[primitiveID1].geometry.positions[0] = primitive1Positions[idBase];
	_PrimitiveBuffer[primitiveID1].geometry.positions[1] = newVertex;
	_PrimitiveBuffer[primitiveID1].geometry.positions[2] = primitive1Positions[idRight];
#endif

	// Fake "gaussian" triangles special case
#ifdef TRIANGLE_GAUSSIAN
#ifdef ALTERNATE_POSITIONS
	float2 offset = (primitive1.geometry.offsets[idRight] - primitive1.geometry.offsets[idLeft]) * 0.15;
	_PrimitiveBuffer[primitiveID0].geometry.offsets[0] += offset;
	_PrimitiveBuffer[primitiveID0].geometry.offsets[2] += offset;
	_PrimitiveBuffer[primitiveID1].geometry.offsets[0] -= offset;
	_PrimitiveBuffer[primitiveID1].geometry.offsets[1] -= offset;
#else
	float3 offset = (primitive1Positions[idRight] - primitive1Positions[idLeft]) * 0.15;
	_PrimitiveBuffer[primitiveID0].geometry.positions[0] += offset;
	_PrimitiveBuffer[primitiveID0].geometry.positions[2] += offset;
	_PrimitiveBuffer[primitiveID1].geometry.positions[0] -= offset;
	_PrimitiveBuffer[primitiveID1].geometry.positions[1] -= offset;
#endif
#endif

	// If we're optimizing in 2D, add small Z offset to one Primitive to avoid Z-fighting
	/*if (_IsOptim2D > 0.5f)
	{
		float rand = WangHash((_CurrentFrame * _PrimitiveCount) + primitiveID0) * (1.0 / 4294967296.0);
		float smallOffset = (rand * 2.0 - 1.0) * 0.0001;
		_PrimitiveBuffer[primitiveID0].positions[0].z += smallOffset;
		_PrimitiveBuffer[primitiveID0].positions[1].z += smallOffset;
		_PrimitiveBuffer[primitiveID0].positions[2].z += smallOffset;
	}*/

	// COLOR
#ifdef TRIANGLE_GRADIENT
	Color newColor = InterpolateColor2(primitive1.colors[idLeft], primitive1.colors[idRight]);
	_PrimitiveBuffer[primitiveID0].colors[0] = primitive1.colors[idBase];
	_PrimitiveBuffer[primitiveID0].colors[1] = primitive1.colors[idLeft];
	_PrimitiveBuffer[primitiveID0].colors[2] = newColor;
	_PrimitiveBuffer[primitiveID1].colors[0] = primitive1.colors[idBase];
	_PrimitiveBuffer[primitiveID1].colors[1] = newColor;
	_PrimitiveBuffer[primitiveID1].colors[2] = primitive1.colors[idRight];
#else
	_PrimitiveBuffer[primitiveID0].color = primitive1.color;
	_PrimitiveBuffer[primitiveID1].color = primitive1.color;
#endif

	// Reset all gradients
	PrimitiveData zeroInit = ZeroInitPrimitiveData();
	_PrimitiveGradientsMoments1[primitiveID0] = zeroInit;
	_PrimitiveGradientsMoments1[primitiveID1] = zeroInit;
	_PrimitiveGradientsMoments2[primitiveID0] = zeroInit;
	_PrimitiveGradientsMoments2[primitiveID1] = zeroInit;
	_PrimitiveOptimStepCounter[primitiveID0] = 0;
	_PrimitiveOptimStepCounter[primitiveID1] = 0;
}

[numthreads(256, 1, 1)]
void TripleResampling(uint3 id : SV_DispatchThreadID)
{
	uint dispatchDistributer = _ArgsResampling[0];
	uint threadID = id.x + id.y * dispatchDistributer * 256;
	if (threadID >= _ArgsResampling[3])
		return;

	// Get current resampling pair (subdivide primitiveA by re-using primitiveB and primitiveC)
	uint primitiveIDA = _SortedValidPrimitiveIDs[threadID].x;
	if (primitiveIDA >= _PrimitiveCount)
		return;
	uint primitiveIDB = _ReadInvalidPrimitiveIDs[threadID * 2 + 0];
	uint primitiveIDC = _ReadInvalidPrimitiveIDs[threadID * 2 + 1];

	PrimitiveData primitiveA = _PrimitiveBuffer[primitiveIDA];
	float3 primitiveAPositions[3];
	primitiveAPositions[0] = GetWorldVertex(primitiveA.geometry, 0);
	primitiveAPositions[1] = GetWorldVertex(primitiveA.geometry, 1);
	primitiveAPositions[2] = GetWorldVertex(primitiveA.geometry, 2);
	PrimitiveData primitiveB = _PrimitiveBuffer[primitiveIDB];
	PrimitiveData primitiveC = _PrimitiveBuffer[primitiveIDC];

	// Handle kill counters
	_PrimitiveKillCounters[primitiveIDA] = _FramesUnseenBeforeKill;
	_PrimitiveKillCounters[primitiveIDB] = _FramesUnseenBeforeKill;
	_PrimitiveKillCounters[primitiveIDC] = _FramesUnseenBeforeKill;

	// GEOMETRY
#ifdef ALTERNATE_POSITIONS
#else
	float3 barycenter = (primitiveAPositions[0] + primitiveAPositions[1] + primitiveAPositions[2]) / 3.0;
	_PrimitiveBuffer[primitiveIDA].geometry.positions[0] = primitiveAPositions[0];
	_PrimitiveBuffer[primitiveIDA].geometry.positions[1] = primitiveAPositions[1];
	_PrimitiveBuffer[primitiveIDA].geometry.positions[2] = barycenter;
	_PrimitiveBuffer[primitiveIDB].geometry.positions[0] = primitiveAPositions[1];
	_PrimitiveBuffer[primitiveIDB].geometry.positions[1] = primitiveAPositions[2];
	_PrimitiveBuffer[primitiveIDB].geometry.positions[2] = barycenter;
	_PrimitiveBuffer[primitiveIDC].geometry.positions[0] = primitiveAPositions[2];
	_PrimitiveBuffer[primitiveIDC].geometry.positions[1] = primitiveAPositions[0];
	_PrimitiveBuffer[primitiveIDC].geometry.positions[2] = barycenter;
#endif

	// COLOR
#ifdef TRIANGLE_GRADIENT
	Color barycenterColor = InterpolateColor3(primitiveA.colors[0], primitiveA.colors[1], primitiveA.colors[2]);
	_PrimitiveBuffer[primitiveIDA].colors[0] = primitiveA.colors[0];
	_PrimitiveBuffer[primitiveIDA].colors[1] = primitiveA.colors[1];
	_PrimitiveBuffer[primitiveIDA].colors[2] = barycenterColor;
	_PrimitiveBuffer[primitiveIDB].colors[0] = primitiveA.colors[1];
	_PrimitiveBuffer[primitiveIDB].colors[1] = primitiveA.colors[2];
	_PrimitiveBuffer[primitiveIDB].colors[2] = barycenterColor;
	_PrimitiveBuffer[primitiveIDC].colors[0] = primitiveA.colors[2];
	_PrimitiveBuffer[primitiveIDC].colors[1] = primitiveA.colors[0];
	_PrimitiveBuffer[primitiveIDC].colors[2] = barycenterColor;
#else
	_PrimitiveBuffer[primitiveIDA].color = primitiveA.color;
	_PrimitiveBuffer[primitiveIDB].color = primitiveA.color;
	_PrimitiveBuffer[primitiveIDC].color = primitiveA.color;
#endif

	// Reset all gradients
	PrimitiveData zeroInit = ZeroInitPrimitiveData();
	_PrimitiveGradientsMoments1[primitiveIDA] = zeroInit;
	_PrimitiveGradientsMoments1[primitiveIDB] = zeroInit;
	_PrimitiveGradientsMoments1[primitiveIDC] = zeroInit;
	_PrimitiveGradientsMoments2[primitiveIDA] = zeroInit;
	_PrimitiveGradientsMoments2[primitiveIDB] = zeroInit;
	_PrimitiveGradientsMoments2[primitiveIDC] = zeroInit;
	_PrimitiveOptimStepCounter[primitiveIDA] = 0;
	_PrimitiveOptimStepCounter[primitiveIDB] = 0;
	_PrimitiveOptimStepCounter[primitiveIDC] = 0;
}
